<HTML>
    <HEAD>
      <TITLE>Humanoid Path Planner Documentation</TITLE>
      <LINK HREF="package.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY>

<h1><a class="anchor" name="hppDoc_development">Developing in Hpp</a></h1>This page explains some development rules applied in Hpp project.<p>
They are mostly common sense rules.<h2><a class="anchor" name="hppDoc_rules">
General rules to be followed in HPP developement</a></h2>
<h3><a class="anchor" name="hppDoc_separate_algo_middleware">
Make clear distinction between algorithms, middleware and graphical interface</a></h3>
<div align="center">
<img src="pictures/archi.png" alt="archi.png">
<p><strong>Architecture of HPP: the functionalities are distributed into separate software packages. The architecture is composed of Three types of packages: algorithms, CORBA interfaces and KPP-SDK interfaces.</strong></p></div>
 HPP is composed of several software packages divided into three groups as explained in the above figure: <ul>
<li>algorithms, </li>
<li>Corba server </li>
<li>KPP-interfaces</li>
</ul>
KPP-interface and Corba server should be considered as visualization and debugging-testing tools. It is mostly important that packages implementing path planning algorithms for humanoid robots are independent from a given middleware (CORBA) and from a given GUI (KineoPathPlanner). As a consequence, no CORBA::xxx attribute should be in a class belonging to the algorithm part.<p>
This simple principle will enable to easily insert the algorithmic software packages into different middlewares (GenoM, RT-middleware for instance).<h3><a class="anchor" name="hppDoc_small_packages">
Modularity</a></h3>
Try to avoid developing huge packages including many functions. Instead, build several small packages with simple interfaces and easy to understand functionalities.<h4><a class="anchor" name="hppDoc_example1">
Example</a></h4>
Let us assume that you are developing a path planning algorithm and you want to use quaternions to represent the orientations of rigid-bodies. <ul>
<li>The first step consists in trying to find an existing implementation of quaternions that you can use. </li>
<li>Let us assume (this is very unlikeky) that you cannot find a good implementation of quaternions, then, instead of developing operations on quaternions in your path planning package, it is much more clever to create a package that will handle quaternion operations and to make your path planning package depend on it. Later, other users will be able to use your quaternion package.</li>
</ul>
<h3><a class="anchor" name="hppDoc_level_generality">
Level of generality</a></h3>
When you implement an algorithm, always ask yourself the question: "Could my algorihtm be applied to applications more general than the one I am dealing with?" If yes, try to make your algorithm take more general input than your practical problem of today.<h4><a class="anchor" name="hppDoc_example2">
Example</a></h4>
Let us assume that you want to implement Newton algoritm to find a root of a polynomial function. Your algorithm requires the derivative of the polynomial. You can get an expression of a polynomial derivative using the polynomial coefficients.<p>
However, it would be more clever to develop the same algorithm taking as input a function that might not be a polynomial. For that you can define an abstract class <div class="fragment"><pre class="fragment"><span class="keyword">class </span>Cmapping {
<span class="keyword">public</span>:
<span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keywordtype">double</span> inParamter) = 0;
<span class="keyword">virtual</span> <span class="keywordtype">double</span> derivative(<span class="keywordtype">double</span> inParamter) = 0;
};
</pre></div> make your Newton implementation take as input an object <code>Cmapping</code> and then derive this class into a concrete polynomial class. Thus, your algorithm can be used by other people wanting to find the root of non-polynomial functions.<h4><a class="anchor" name="hppDoc_humanoid">
Humanoid robots</a></h4>
The algorithms we develop are mostly applied to one type of humanoid robot: HRP2. It is therefore important to develop these algorithms in such a way that they can be applied to any other humanoid robot. For that developers should avoid to make too strong asumptions about the robot structure. The abstract <a class="elRef" doxygen="abstractRobotDynamics.doxytag:/home/florent/devel/share/doc/abstractRobotDynamics/" href="/home/florent/devel/share/doc/abstractRobotDynamics/class_cjrl_humanoid_dynamic_robot.html">CjrlHumanoidDynamicRobot</a> interface for dynamic humanoid robots have been designed in this aim.<h2><a class="anchor" name="hppDoc_howto">
How to implement a new algorithm in HPP.</a></h2>
To implement a new algorithm in HPP, you need to create new software packages as described below. To create new software packages, we advise developers to use perl script <code>packageCreate</code>. <div class="fragment"><pre class="fragment">[~] cd devel/src
[src] cg-clone git+ssh:<span class="comment">//[git|softs].laas.fr/git/robots/scripts</span>
</pre></div><h3><a class="anchor" name="hppDoc_new_algo">
Create a new software package implementing your algorithm</a></h3>
To create a new package depending on <code>hppCore</code>, type the following commands. <div class="fragment"><pre class="fragment">[~] cd devel/src
[src] perl ./scripts/packageCreate hppNewAlgo -d hppCore HPPCORE
</pre></div> If you want your package to depend on other packages add -d package PACKAGE for each dependence.<p>
This operation creates a template of software package with all necessary files to compile. There are four subdirectories in this package: <ul>
<li><code>doc:</code> contains necessary files to generate doxygen documentation, </li>
<li><code>include</code> contains headers files </li>
<li><code>src</code> contains source code files </li>
<li><code>unitTesting</code> contains files used to test the algorithm developed in the package.</li>
</ul>
Define in <code>include/hppNewAlgo.h</code> a class that derives from <a class="elRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_planner.html">ChppPlanner</a>. <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/hpp_planner_8h.html">hppPlanner.h</a>"</span>

<span class="keyword">class </span>ChppNewAlgo : <span class="keyword">public</span> <a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_planner.html">ChppPlanner</a> {
<span class="keyword">public</span>:
...
ktStatus solve();
};
</pre></div> Class <a class="elRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_planner.html">ChppPlanner</a> proposes an interface function to insert a robot: <div class="fragment"><pre class="fragment">ktStatus <a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_planner.html#ae97b965a558adbb67f533af99b5684b">ChppPlanner::addHppProblem</a>(CkppDeviceComponentShPtr robot); 
</pre></div> Independently from how the robot is inserted into the object, you can use it as the input of your algorithm in your class ChppNewAlgo: <div class="fragment"><pre class="fragment">CkppDeviceComponentShPtr robot = robotIthProblem(0);
</pre></div><p>
Write in <code>src/hppNewAlgo.cpp</code> function <div class="fragment"><pre class="fragment">ktStatus <a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_planner.html#28677849b078e3d3034c6d4d4fd9f21b">ChppNewAlgo::solve</a>()
{
  CkwsPath path = resultOfNewAlgo();

  <a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_problem.html">ChppProblem</a>&amp; hppProblem = hppProblemVector[problemId];
  hppProblem.<a class="codeRef" doxygen="hppCore.doxytag:/home/florent/devel/share/doc/hppCore/" href="/home/florent/devel/share/doc/hppCore/class_chpp_problem.html#de3c360a44cad80c2650c69cd80c9c82">addPath</a>(kwsPath);
}
</pre></div> that runs your algorithm. The two last lines insert the result of your path in KPP interface if the interface is running.<p>
To compile and install your package do the following step: <div class="fragment"><pre class="fragment">[~] cd devel/src/hppNewAlgo
[hppNewAlgo] aclocal
[hppNewAlgo] libtoolize -c
[hppNewAlgo] autoconf
[hppNewAlgo] automake -ac
[hppNewAlgo] mkdir build
[hppNewAlgo] cd build
[hppNewAlgo] ../configure --prefix=${HOME}/devel
[hppNewAlgo] make
[hppNewAlgo] make install
</pre></div><h3><a class="anchor" name="hppDoc_new_interface">
Create a new KPP-interface for your package</a></h3>
To be able to see the result of your algorithm, you need to create a new KPP-interface deriving from CkppInterface <div class="fragment"><pre class="fragment">[~] cd devel/src
[src] perl ./scripts/packageCreate kppInterfaceNewAlgo -d kppInterface KPPINTERFACE -d hppNewAlgo HPPNEWALGO
</pre></div> and depending on your algorithm software package.<p>
See package <code>kppInterfaceTutorial</code> for an example, and especially for managing Kineo license issue in <code>src/Makefile.am</code> <div class="fragment"><pre class="fragment">[~] cd devel/src
[src] cg-clone git+ssh:<span class="comment">//[git|softs].laas.fr/git/jrl/hppTutorialPlanner</span>
[src] cg-clone git+ssh:<span class="comment">//[git|softs].laas.fr/git/jrl/kppInterfaceTutorial</span>
</pre></div><p>
To run your interface into KineoPathPlanner, do the following: <div class="fragment"><pre class="fragment">[~] KineoPathPlanner -ModulePath ${HOME}/lib/modules/${HOST}/libkppInterfaceNewAlgo
</pre></div>  <br><br>
 <hr>
 <center>
 <img src="./pictures/footer.jpg" Height=100>
 <br>Humanoid Path Planner documentation</br>
 </center>
 <hr>
 </center>
 </body>
 </head>

